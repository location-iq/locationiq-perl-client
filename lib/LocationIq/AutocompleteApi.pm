=begin comment

LocationIQ

LocationIQ provides flexible enterprise-grade location based solutions. We work with developers, startups and enterprises worldwide serving billions of requests everyday. This page provides an overview of the technical aspects of our API and will help you get started.

The version of the OpenAPI document: 1.1.0

Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package LocationIq::AutocompleteApi;

require 5.6.0;
use strict;
use warnings;
use utf8; 
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use LocationIq::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'LocationIq::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = LocationIq::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# autocomplete
#
# 
# 
# @param string $q Address to geocode (required)
# @param int $normalizecity For responses with no city value in the address section, the next available element in this order - city_district, locality, town, borough, municipality, village, hamlet, quarter, neighbourhood - from the address section will be normalized to city. Defaults to 1 for SDKs. (required)
# @param int $limit Limit the number of returned results. Default is 10. (optional, default to 10)
# @param string $viewbox The preferred area to find search results.  To restrict results to those within the viewbox, use along with the bounded option. Tuple of 4 floats. Any two corner points of the box - &#x60;max_lon,max_lat,min_lon,min_lat&#x60; or &#x60;min_lon,min_lat,max_lon,max_lat&#x60; - are accepted in any order as long as they span a real box.  (optional)
# @param int $bounded Restrict the results to only items contained with the viewbox (optional)
# @param string $countrycodes Limit search to a list of countries. (optional)
# @param string $accept_language Preferred language order for showing search results, overrides the value specified in the Accept-Language HTTP header. Defaults to en. To use native language for the response when available, use accept-language&#x3D;native (optional)
# @param string $tag Restricts the autocomplete search results to elements of specific OSM class and type.  Example - To restrict results to only class place and type city: tag&#x3D;place:city, To restrict the results to all of OSM class place: tag&#x3D;place (optional)
{
    my $params = {
    'q' => {
        data_type => 'string',
        description => 'Address to geocode',
        required => '1',
    },
    'normalizecity' => {
        data_type => 'int',
        description => 'For responses with no city value in the address section, the next available element in this order - city_district, locality, town, borough, municipality, village, hamlet, quarter, neighbourhood - from the address section will be normalized to city. Defaults to 1 for SDKs.',
        required => '1',
    },
    'limit' => {
        data_type => 'int',
        description => 'Limit the number of returned results. Default is 10.',
        required => '0',
    },
    'viewbox' => {
        data_type => 'string',
        description => 'The preferred area to find search results.  To restrict results to those within the viewbox, use along with the bounded option. Tuple of 4 floats. Any two corner points of the box - &#x60;max_lon,max_lat,min_lon,min_lat&#x60; or &#x60;min_lon,min_lat,max_lon,max_lat&#x60; - are accepted in any order as long as they span a real box. ',
        required => '0',
    },
    'bounded' => {
        data_type => 'int',
        description => 'Restrict the results to only items contained with the viewbox',
        required => '0',
    },
    'countrycodes' => {
        data_type => 'string',
        description => 'Limit search to a list of countries.',
        required => '0',
    },
    'accept_language' => {
        data_type => 'string',
        description => 'Preferred language order for showing search results, overrides the value specified in the Accept-Language HTTP header. Defaults to en. To use native language for the response when available, use accept-language&#x3D;native',
        required => '0',
    },
    'tag' => {
        data_type => 'string',
        description => 'Restricts the autocomplete search results to elements of specific OSM class and type.  Example - To restrict results to only class place and type city: tag&#x3D;place:city, To restrict the results to all of OSM class place: tag&#x3D;place',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'autocomplete' } = { 
        summary => '',
        params => $params,
        returns => 'ARRAY[object]',
        };
}
# @return ARRAY[object]
#
sub autocomplete {
    my ($self, %args) = @_;

    # verify the required parameter 'q' is set
    unless (exists $args{'q'}) {
      croak("Missing the required parameter 'q' when calling autocomplete");
    }

    # verify the required parameter 'normalizecity' is set
    unless (exists $args{'normalizecity'}) {
      croak("Missing the required parameter 'normalizecity' when calling autocomplete");
    }

    # parse inputs
    my $_resource_path = '/autocomplete.php';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'q'}) {
        $query_params->{'q'} = $self->{api_client}->to_query_value($args{'q'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'viewbox'}) {
        $query_params->{'viewbox'} = $self->{api_client}->to_query_value($args{'viewbox'});
    }

    # query params
    if ( exists $args{'bounded'}) {
        $query_params->{'bounded'} = $self->{api_client}->to_query_value($args{'bounded'});
    }

    # query params
    if ( exists $args{'countrycodes'}) {
        $query_params->{'countrycodes'} = $self->{api_client}->to_query_value($args{'countrycodes'});
    }

    # query params
    if ( exists $args{'normalizecity'}) {
        $query_params->{'normalizecity'} = $self->{api_client}->to_query_value($args{'normalizecity'});
    }

    # query params
    if ( exists $args{'accept_language'}) {
        $query_params->{'accept-language'} = $self->{api_client}->to_query_value($args{'accept_language'});
    }

    # query params
    if ( exists $args{'tag'}) {
        $query_params->{'tag'} = $self->{api_client}->to_query_value($args{'tag'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(key )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[object]', $response);
    return $_response_object;
}

1;
